<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Projection Onto 2D Canvas</title>
    <link href="prism-code/prism.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        
        header {
            background-color: #1f1f1f;
            padding: 20px;
            text-align: center;
            color: #ffffff;
        }
        
        h1 {
            margin: 0;
        }
        
        h3 {
            margin: 10px 0 20px;
            color: #b0b0b0;
        }
        
        a {
            color: #4a90e2;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        .content {
            max-width: 900px;
            margin: auto;
            padding: 20px;
        }
        
        pre {
            background: #2e2e2e;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        code {
            color: #f8f8f2;
        }
        
        .slider-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 5px;
            background: #555;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }
        
        img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        
        footer {
            background-color: #1f1f1f;
            padding: 10px;
            text-align: center;
            color: #b0b0b0;
        }
        
        footer a {
            color: #4a90e2;
        }
    </style>
</head>

<body>
    <header>
        <h1>3D Projection Onto 2D Canvas</h1>
        <h3>Eitan Alperstein</h3>
    </header>

    <div class="content">
        <p><strong>TL;DR:</strong><br>
            <a href="https://github.com/Eitan-Alperstein/3D-Cube">Source Code (demo is in index.html and script.js)</a><br>
            <a href="https://projection.eitanalperstein.com">Demo</a>
        </p>

        <p>Ever wondered how a three-dimensional object gets displayed on a two-dimensional computer screen? It's actually quite simple. With basic geometry, you can project 3D objects onto a 2D canvas using HTML, CSS, and JavaScript, without the need for
            WebGL or a GPU.</p>

        <h2>Getting Started</h2>

        <p>First, let's create the canvas we'll be drawing on. Hereâ€™s a basic HTML setup:</p>
        <pre class="language-html line-numbers" data-prismjs-copy="Copy to clipboard">
<code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;3D -> 2D Projection&lt;/title&gt;
        &lt;style&gt;
            body {
                background-color: #222;
                overflow: hidden;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
        &lt;script src="script.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

        <p>Now, let's code the <code>script.js</code> file to connect to the canvas:</p>
        <pre class="language-javascript line-numbers match-braces" data-prismjs-copy="Copy to clipboard">
<code>const canvas = document.querySelector("#canvas");
const context = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 250;

const X_CENTER = canvas.width / 2;
const Y_CENTER = canvas.height / 2;

context.fillStyle = "black";
context.strokeStyle = "white";</code></pre>

        <p>Here, we set up our canvas and context, define the canvas size, and center the drawing area. We then make the lines white. Next, we define the vertices of our cube and create the necessary projections:</p>
        <pre class="language-javascript line-numbers match-braces" data-prismjs-copy="Copy to clipboard">
<code>let VERTICES = [
    [0, 0, 30],
    [0, 300, 30],
    [300, 0, 30],
    [300, 300, 30],
    [0, 0, 60],
    [0, 300, 60],
    [300, 0, 60],
    [300, 300, 60],
];

let INDICES = [
    [0, 1],
    [1, 3],
    [3, 2],
    [2, 0],
    [4, 5],
    [5, 7],
    [7, 6],
    [6, 4],
    [0, 4],
    [1, 5],
    [3, 7],
    [2, 6],
];

var projectedVertices = [];

function updateCanvas() {
    projectedVertices = [];
    context.clearRect(0, 0, canvas.width, canvas.height);

    for (let vertex of VERTICES) {
        let onScreenCoordinate = [0, 0];
        onScreenCoordinate[0] = vertex[0];
        onScreenCoordinate[1] = vertex[1];
        projectedVertices.push(onScreenCoordinate);
    }

    for (let [startCoordinate, endCoordinate] of INDICES) {
        context.beginPath();
        context.moveTo(projectedVertices[startCoordinate][0], projectedVertices[startCoordinate][1]);
        context.lineTo(projectedVertices[endCoordinate][0], projectedVertices[endCoordinate][1]);
        context.stroke();
    }
}

updateCanvas();</code></pre>

        <h2>Understanding the Projection</h2>
        <ol>
            <li>The vertices define the points of the cube, and the indices describe which points connect to form the edges.</li>
            <li>We transform 3D coordinates to 2D by ignoring the z-axis initially. The <code>updateCanvas</code> function handles this conversion and draws the lines connecting the projected vertices.</li>
        </ol>

        <p>If done correctly, you should see a flat white square. To incorporate the third dimension into the projection, we use geometry to calculate where each vertex appears on the screen based on its z-coordinate and a focal length:</p>
        <pre class="language-javascript line-numbers match-braces" data-prismjs-copy="Copy to clipboard">
<code>var focalLength = 5;

for (let vertex of VERTICES) {
    let onScreenCoordinate = [0, 0];
    onScreenCoordinate[0] = (focalLength * vertex[0]) / (focalLength + vertex[2]);
    onScreenCoordinate[1] = (focalLength * vertex[1]) / (focalLength + vertex[2]);
    projectedVertices.push(onScreenCoordinate);
}</code></pre>

        <p>To manipulate the focal length, add a slider to your HTML:</p>
        <pre class="language-html line-numbers" data-prismjs-copy="Copy to clipboard">
<code>&lt;div class="slider-container"&gt;
    &lt;p&gt;Focal Length&lt;/p&gt;
    &lt;input type="range" min="0" max="200" value="20" step="0.05" class="slider" id="focal" oninput="updateCanvas()"&gt;
&lt;/div&gt;</code></pre>

        <p>And some CSS for styling the slider:</p>
        <pre class="language-css line-numbers" data-prismjs-copy="Copy to clipboard">
<code>.slider {
    -webkit-appearance: none;
    width: 100%;
    height: 15px;
    border-radius: 5px;
    background: #555;
    outline: none;
    opacity: 0.9;
    transition: opacity .2s;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4a90e2;
    cursor: pointer;
}

.slider::-moz-range-thumb {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4a90e2;
    cursor: pointer;
}

p {
    color: #e0e0e0;
    font-family: Arial, sans-serif;
}</code></pre>

        <p>Update the JavaScript to read the slider value and adjust the focal length:</p>
        <pre class="language-javascript line-numbers" data-prismjs-copy="Copy to clipboard">
<code>let focalLength = parseFloat(document.querySelector("#focal").value);</code></pre>

        <p>Additionally, to enhance the effect, consider adding sliders to control the camera's X and Y positions:</p>
        <pre class="language-html line-numbers" data-prismjs-copy="Copy to clipboard">
<code>&lt;div class="slider-container"&gt;
    &lt;p&gt;Camera X&lt;/p&gt;
    &lt;input type="range" min="-400" max="400" value="5" step="0.05" class="slider" id="cx" oninput="updateCanvas()"&gt;
&lt;/div&gt;
&lt;div class="slider-container"&gt;
    &lt;p&gt;Camera Y&lt;/p&gt;
    &lt;input type="range" min="-400" max="400" value="5" step="0.05" class="slider" id="cy" oninput="updateCanvas()"&gt;
&lt;/div&gt;</code></pre>

        <p>Update the projection calculation to account for the camera position:</p>
        <pre class="language-javascript line-numbers" data-prismjs-copy="Copy to clipboard">
<code>onScreenCoordinate[0] = (focalLength * (vertex[0] - cameraX)) / (focalLength + vertex[2]) + X_CENTER;
onScreenCoordinate[1] = (focalLength * (vertex[1] - cameraY)) / (focalLength + vertex[2]) + Y_CENTER;</code></pre>

        <h3>Closing Notes</h3>
        <p>This project demonstrates the fundamentals of 3D projection onto a 2D plane with simple math and JavaScript. For a challenge, consider adding colors to the faces of the cube or exploring more advanced projections.</p>

        <p>For further exploration:</p>
        <p><a href="https://github.com/Eitan-Alperstein/3D-Cube">Source Code (demo is in index.html and script.js)</a><br>
            <a href="https://projection.eitanalperstein.com">Demo</a>
        </p>
    </div>

    <footer>
        &copy; 2024 Eitan Alperstein
    </footer>

    <script src="prism.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>

</html>