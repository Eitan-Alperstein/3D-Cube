<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Projection Onto 2D Canvas</title>
    <link href="prism-code/prism.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        
        header {
            background-color: #1f1f1f;
            padding: 20px;
            text-align: center;
            color: #ffffff;
        }
        
        h1 {
            margin: 0;
        }
        
        h3 {
            margin: 10px 0 20px;
            color: #b0b0b0;
        }
        
        a {
            color: #4a90e2;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        .content {
            max-width: 900px;
            margin: auto;
            padding: 20px;
        }
        
        pre {
            background: #2e2e2e;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        code {
            color: #f8f8f2;
        }
        
        .slider-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 5px;
            background: #555;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
        }
        
        img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        
        footer {
            background-color: #1f1f1f;
            padding: 10px;
            text-align: center;
            color: #b0b0b0;
        }
        
        footer a {
            color: #4a90e2;
        }
    </style>
</head>

<body>
    <header>
        <h1>3D Projection Onto 2D Canvas</h1>
        <h3>Eitan Alperstein</h3>
    </header>

    <div class="content">
        <p><strong>TL;DR:</strong><br>
            <a href="https://github.com/Eitan-Alperstein/3D-Cube">Source Code (demo is in index.html and script.js)</a><br>
            <a href="https://projection.eitanalperstein.com">Demo</a>
        </p>

        <b style="color:red">Unfinished and unmaintained; might finish later.</b>

        <p>Ever wondered how a three-dimensional object gets displayed on a two-dimensional computer screen? It's actually quite simple. With basic geometry, you can project 3D objects onto a 2D canvas using HTML, CSS, and JavaScript, without the need for
            WebGL or a GPU.</p>

        <h2>Getting Started</h2>

        <p>First, let's create the canvas we'll be drawing on. Here’s a basic HTML setup:</p>
        <pre class="language-html" data-prismjs-copy="Copy to clipboard">
<code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;3D -> 2D Projection&lt;/title&gt;
        &lt;style&gt;
            body {
                background-color: #222;
                overflow: hidden;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
        &lt;script src="script.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

        <p>And set up our <code>script.js</code> file:</p>
        <pre class="language-javascript match-braces" data-prismjs-copy="Copy to clipboard">
<code>const canvas = document.querySelector("#canvas");
const context = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 250;

const X_CENTER = canvas.width / 2;
const Y_CENTER = canvas.height / 2;

context.strokeStyle = "white";</code></pre>

        <p>Here, we set up our canvas and tell the browser that it is 2D, rather than webgl or 3D, set the canvas to the width of the browser tab and the height of the tab (minus a few hundred pixels for the sliders we'll add later), and define the center
            of our canvas. We then make all lines white. Now, we need to define the vertices of our cube and create the necessary projections:</p>
        <pre class="language-javascript  match-braces" data-prismjs-copy="Copy to clipboard">
<code>let VERTICES = [
    [0, 0, 30],
    [0, 300, 30],
    [300, 0, 30],
    [300, 300, 30],
    [0, 0, 60],
    [0, 300, 60],
    [300, 0, 60],
    [300, 300, 60],
];

let INDICES = [
    [0, 1],
    [1, 3],
    [3, 2],
    [2, 0],
    [4, 5],
    [5, 7],
    [7, 6],
    [6, 4],
    [0, 4],
    [1, 5],
    [3, 7],
    [2, 6],
];

var projectedVertices = [];

function updateCanvas() {
    projectedVertices = [];
    context.clearRect(0, 0, canvas.width, canvas.height);

    for (let vertex of VERTICES) {
        let onScreenCoordinate = [0, 0];
        onScreenCoordinate[0] = vertex[0];
        onScreenCoordinate[1] = vertex[1];
        projectedVertices.push(onScreenCoordinate);
    }

    for (let [startCoordinate, endCoordinate] of INDICES) {
        context.beginPath();
        context.moveTo(projectedVertices[startCoordinate][0], projectedVertices[startCoordinate][1]);
        context.lineTo(projectedVertices[endCoordinate][0], projectedVertices[endCoordinate][1]);
        context.stroke();
    }
}

updateCanvas();</code></pre>

        <h2>Understanding the Projection Code</h2>
        <ol>
            <li>Define the cube's vertices in 3D coordinates. In essence, we are making two flat squares, with one being z=30 and the other z=60.</li>
            <li>Define the indices. These are the lines that will connect our vertices once we turn them into coordinates on the canvas. Usually, index arrays are one dimensional, but our code will be easier to understand and write if we can define a start
                and end point to every line we make.</li>
            <li>Initialize our <code>projectedVertices</code> array, which will hold the 2D coordinates of our cube's vertices once we have done the appropriate math on them.</li>
            <li>Define the <code>updateCanvas()</code> function.
                <ol>
                    <li>Reset <code>projectedVertices</code></li>
                    <li>Clear the canvas.</li>
                    <li>Loop through <code>VERTICES</code>. We'll eventually need to apply our math to each vertex, but for now, we'll just ignore the z-axis for proof of concept.</li>
                    <li>Loop through <code>INDICES</code>, taking each starting point and ending point from <code>projectedVertices</code> and drawing a line through it.</li>
                </ol>
            </li>
            <li>Call our function.</li>
        </ol>

        <p>If done correctly, you should see a flat white square. To incorporate the third dimension into the projection, we use geometry to calculate where each vertex appears on the screen based on its z-coordinate and a focal length:</p>
        <pre class="language-javascript  match-braces" data-prismjs-copy="Copy to clipboard">
<code>var focalLength = 5;

for (let vertex of VERTICES) {
    let onScreenCoordinate = [0, 0];
    onScreenCoordinate[0] = (focalLength * vertex[0]) / (focalLength + vertex[2]);
    onScreenCoordinate[1] = (focalLength * vertex[1]) / (focalLength + vertex[2]);
    projectedVertices.push(onScreenCoordinate);
}</code></pre>

        <p>To manipulate the focal length, add a slider to your HTML:</p>
        <pre class="language-html " data-prismjs-copy="Copy to clipboard">
<code>&lt;div class="slider-container"&gt;
    &lt;p&gt;Focal Length&lt;/p&gt;
    &lt;input type="range" min="0" max="200" value="20" step="0.05" class="slider" id="focal" oninput="updateCanvas()"&gt;
&lt;/div&gt;</code></pre>

        <p>And some CSS for styling the slider:</p>
        <pre class="language-css " data-prismjs-copy="Copy to clipboard">
<code>.slider {
    -webkit-appearance: none;
    width: 100%;
    height: 15px;
    border-radius: 5px;
    background: #555;
    outline: none;
    opacity: 0.9;
    transition: opacity .2s;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4a90e2;
    cursor: pointer;
}

.slider::-moz-range-thumb {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4a90e2;
    cursor: pointer;
}

p {
    color: #e0e0e0;
    font-family: Arial, sans-serif;
}</code></pre>

        <p>Update the JavaScript to read the slider value and adjust the focal length:</p>
        <pre class="language-javascript " data-prismjs-copy="Copy to clipboard">
<code>let focalLength = parseFloat(document.querySelector("#focal").value);</code></pre>

        <p>Additionally, to enhance the effect, consider adding sliders to control the camera's X and Y positions:</p>
        <pre class="language-html " data-prismjs-copy="Copy to clipboard">
<code>&lt;div class="slider-container"&gt;
    &lt;p&gt;Camera X&lt;/p&gt;
    &lt;input type="range" min="-400" max="400" value="5" step="0.05" class="slider" id="cx" oninput="updateCanvas()"&gt;
&lt;/div&gt;
&lt;div class="slider-container"&gt;
    &lt;p&gt;Camera Y&lt;/p&gt;
    &lt;input type="range" min="-400" max="400" value="5" step="0.05" class="slider" id="cy" oninput="updateCanvas()"&gt;
&lt;/div&gt;</code></pre>

        <p>Update the projection calculation to account for the camera position:</p>
        <pre class="language-javascript " data-prismjs-copy="Copy to clipboard">
<code>onScreenCoordinate[0] = (focalLength * (vertex[0] - cameraX)) / (focalLength + vertex[2]) + X_CENTER;
onScreenCoordinate[1] = (focalLength * (vertex[1] - cameraY)) / (focalLength + vertex[2]) + Y_CENTER;</code></pre>

        <h3>Closing Notes</h3>
        <p>This project demonstrates the fundamentals of 3D projection onto a 2D plane with simple math and JavaScript. For a challenge, consider adding colors to the faces of the cube or exploring more advanced projections.</p>

        <p>For further exploration:</p>
        <p><a href="https://github.com/Eitan-Alperstein/3D-Cube">Source Code (demo is in index.html and script.js)</a><br>
            <a href="https://projection.eitanalperstein.com">Demo</a>
        </p>
    </div>

    <footer>
        &copy; 2024 Eitan Alperstein
    </footer>

    <!-- NOTE: While trying to style my article with ChatGPT, it changed all of my text. Too lazy to go line by line and change it back. It is what it is. ¯\_(ツ)_/¯ -->

    <script src="prism.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>

</html>